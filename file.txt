
**variables.tf**
```plain
variable "admin_user" {
  type = string
  default = "admin"
}

variable "admin_password" {
  type = string
  default = "password"
}

**outputs.tf**
```plain
output "grafana_url" {
  value = "http://localhost:3000"
}

**docker-compose.yml**

**README.md**
```markdown
# Grafana Setup

## Prerequisites

* Terraform installed on your machine
* Docker installed on your machine

## Setup

1. Initialize the Terraform working directory: `terraform init`
2. Create a `terraform.tfvars` file with the following content:
```plaintext
admin_user = "your_admin_user"
admin_password = "your_admin_password"
Replace `your_admin_user` and `your_admin_password` with your desired values.
3. Apply the Terraform configuration: `terraform apply`
4. Once the deployment is complete, you can access Grafana at `http://localhost:3000`

## Using the Setup

* Log in to Grafana with the admin user and password you set in the `terraform.tfvars` file.
* You can now add dashboards, users, and data sources as needed.

## Notes

* This setup uses a local Docker volume for persistent storage. If you want to use a different storage solution, you can modify the `main.tf` file accordingly.
* Make sure to keep your `terraform.tfvars` file secure, as it contains sensitive information (admin user and password).

You can now use the `terraform apply` command to deploy Grafana to your local machine, and access it at `http://localhost:3000`.
terraform {
  required_version = ">= 1.1.0"

  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "2.19.0"
    }
  }
}

provider "docker" {
  host = "unix:///var/run/docker.sock"
}

resource "docker_container" "grafana" {
  name  = "grafana"
  image = "grafana/grafana:8.3.5"
  ports = ["3000:3000"]
  volumes = [
    "${path.module}/grafana-data:/var/lib/grafana"
  ]
  environment = [
    "GF_SECURITY_ADMIN_USER=${var.admin_user}",
    "GF_SECURITY_ADMIN_PASSWORD=${var.admin_password}"
  ]
  depends_on = [docker_volume.grafana_data]
}

resource "docker_volume" "grafana_data" {
  name = "grafana-data"
}

**variables.tf**
variable "admin_user" {
  type = string
  default = "admin"
}

variable "admin_password" {
  type = string
  default = "password"
}

**outputs.tf**
output "grafana_url" {
  value = "http://localhost:3000"
}

**docker-compose.yml**
version: '3'

services:
  grafana:
    image: grafana/grafana:8.3.5
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana
    environment:
      - GF_SECURITY_ADMIN_USER=${ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${ADMIN_PASSWORD}

volumes:
  grafana-data:

**README.md**
# Grafana Setup using Terraform and Docker

This setup uses Terraform to provision infrastructure locally using the `kreuzwerker/docker` provider, and Docker to run Grafana as a container.

**Prerequisites**

* Docker installed on your machine
* Terraform installed on your machine

**Instructions**

1. Run `terraform init` to initialize the Terraform working directory.
2. Run `terraform apply` to provision the infrastructure and start the Grafana container.
3. Access Grafana at `http://localhost:3000` using the admin user and password specified in the `variables.tf` file.

**Environment Variables**

The `admin_user` and `admin_password` variables are set using environment variables. You can override these variables by setting environment variables before running `terraform apply`. For example:

* `ADMIN_USER=your_admin_user terraform apply`
* `ADMIN_PASSWORD=your_admin_password terraform apply`

**Persistent Storage**

The Grafana data is stored in a local volume named `grafana-data`. This ensures that the data is persisted even after the container is restarted or deleted.

**Troubleshooting**

* Check the Grafana container logs using `docker logs -f grafana`
* Check the Terraform output for any errors or warnings
* Check the Docker volume size and adjust as needed using `docker volume inspect grafana-data` and `docker volume prune`
**Explanation:**

* We define two services: `grafana` and `db`. `grafana` uses the official Grafana image and exposes port 3000.
* The `db` service uses the official Postgres image and sets environment variables for the database. It also mounts a persistent volume at `/var/lib/postgresql/data` to store database data.
* The `grafana` service depends on the `db` service, meaning that Grafana will only start once the database is up and running.
* We use a bridge network (`app`) to allow communication between the services.
* We set the `GF_SERVER_HTTP_PORT` and `GF_SERVER_HOST` environment variables to configure Grafana to listen on port 3000 and bind to `localhost`.

Best practices:

* We use a dedicated network (`app`) to isolate the services and prevent conflicts with other networks.
* We use persistent volumes to store database data, ensuring that changes are persisted even if the container is restarted or deleted.
* We use the `restart: always` option to ensure that the services are restarted if they exit or crash.

Kubernetes configuration (optional):

If you prefer to use Kubernetes, you can create a Deployment YAML file:
**Explanation:**

* We define a Deployment named `grafana` with a single replica.
* The Deployment template includes a single container with the same configuration as the Docker Compose file.
* We use a Persistent Volume Claim named `grafana-db-data` to request storage for the database.
* We define a Service named `db` to expose the database.
* We define an Ingress resource to allow incoming traffic to the `grafana` service.

Best practices:

* We use a Deployment to manage the lifecycle of the Grafana container.
* We use a Persistent Volume Claim to request storage for the database.
* We use a Service to expose the database to the `grafana` service.
* We use an Ingress resource to allow incoming traffic to the `grafana` service.
Let me explain the configuration:

* We use version 3 of the Docker Compose syntax.
* We define a single service named `grafana` that uses the official Grafana 8.3.4 image.
* We map port 3000 on the host machine to port 3000 in the container using the `ports` directive.
* We set environment variables for the Grafana server, including the HTTP port, root URL, and admin credentials.
* We use the `depends_on` directive to ensure that the Grafana service depends on the `db` service (which is not defined in this example, but you would need to define it if you want to use a separate database).
* We use two volumes: `grafana-config` and `grafana-data`. The `grafana-config` volume persists the Grafana configuration files, while the `grafana-data` volume persists the Grafana data (e.g., dashboards, alerts, etc.).

**Best practices:**

* We use a specific version of the Grafana image to ensure consistency and reproducibility.
* We use environment variables to configure the Grafana server, which makes it easier to manage and maintain.
* We use volumes to persist data and configuration, which ensures that data is not lost in case the container is restarted or deleted.
* We use the `depends_on` directive to ensure that services are started in the correct order.

**Kubernetes deployment (if you prefer):**

Here is an example of a Kubernetes deployment YAML file that deploys Grafana on port 3000:
This deployment YAML file defines a single replica of the Grafana container, maps port 3000 on the host machine to port 3000 in the container, sets environment variables, and mounts two persistent volumes (PVCs) for configuration and data persistence.

**Networking:**

In both examples, we use the `ports` directive to expose port 3000 on the host machine. This allows you to access Grafana from outside the container or pod.

**Persistence:**

In both examples, we use volumes to persist data and configuration. In the Docker Compose example, we use two named volumes (`grafana-config` and `grafana-data`) that persist data and configuration. In the Kubernetes example, we use two persistent volume claims (PVCs) (`grafana-config-pvc` and `grafana-data-pvc`) to persist data and configuration.

Note that you may need to adjust the configuration based on your specific use case and requirements.
version: '3'
services:
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SERVER_HTTP_PORT=3000
      - GF_DEFAULT_ADMIN_PASSWORD=your_password
      - GF_DEFAULT_ADMIN_USER=your_username
    volumes:
      - grafana-data:/var/lib/grafana
    restart: always

volumes:
  grafana-data:
    driver: local
Let me explain the configuration:

* `version: '3'`: This specifies the Docker Compose version.
* `services`: This section defines the services that will be created.
* `grafana`: This is the service definition for Grafana.
* `image: grafana/grafana:latest`: This uses the latest stable Grafana image.
* `ports`: This maps port 3000 on the host machine to port 3000 in the container.
* `environment`: This sets environment variables for Grafana.
	+ `GF_SERVER_HTTP_PORT=3000`: This sets the HTTP port for Grafana.
	+ `GF_DEFAULT_ADMIN_PASSWORD=your_password`: This sets the default admin password. Replace `your_password` with your desired password.
	+ `GF_DEFAULT_ADMIN_USER=your_username`: This sets the default admin username. Replace `your_username` with your desired username.
* `volumes`: This section defines persistent volumes.
	+ `grafana-data:/var/lib/grafana`: This mounts a persistent volume at `/var/lib/grafana` in the container, which is where Grafana stores its data.
	+ `driver: local`: This specifies that the volume should be stored on the local file system.
* `restart: always`: This ensures that the Grafana service is restarted if it exits or crashes.

To use this configuration, create a file named `docker-compose.yml` with the above contents, then run `docker-compose up -d` to start the service in detached mode. You can then access Grafana at `http://localhost:3000`.
