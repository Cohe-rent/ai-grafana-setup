Here is an example of production-grade infrastructure code to deploy Grafana using Docker Compose:

**docker-compose.yml**
```yaml
version: '3'

services:
  grafana:
    image: grafana/grafana:7.4.4
    ports:
      - "3000:3000"
    environment:
      - GF_SERVER_HTTP_PORT=3000
      - GF_SERVER_HOST=localhost
    restart: always
    depends_on:
      - db
    networks:
      - app

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=grafana
      - POSTGRES_PASSWORD=grafana
      - POSTGRES_DB=grafana
    volumes:
      - db-data:/var/lib/postgresql/data
    restart: always
    networks:
      - app

volumes:
  db-data:

networks:
  app:
    driver: bridge
```
**Explanation:**

* We define two services: `grafana` and `db`. `grafana` uses the official Grafana image and exposes port 3000.
* The `db` service uses the official Postgres image and sets environment variables for the database. It also mounts a persistent volume at `/var/lib/postgresql/data` to store database data.
* The `grafana` service depends on the `db` service, meaning that Grafana will only start once the database is up and running.
* We use a bridge network (`app`) to allow communication between the services.
* We set the `GF_SERVER_HTTP_PORT` and `GF_SERVER_HOST` environment variables to configure Grafana to listen on port 3000 and bind to `localhost`.

Best practices:

* We use a dedicated network (`app`) to isolate the services and prevent conflicts with other networks.
* We use persistent volumes to store database data, ensuring that changes are persisted even if the container is restarted or deleted.
* We use the `restart: always` option to ensure that the services are restarted if they exit or crash.

Kubernetes configuration (optional):

If you prefer to use Kubernetes, you can create a Deployment YAML file:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:7.4.4
        ports:
        - containerPort: 3000
        environment:
          - GF_SERVER_HTTP_PORT=3000
          - GF_SERVER_HOST=localhost
        volumeMounts:
        - name: db-data
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: db-data
        persistentVolumeClaim:
          claimName: grafana-db-data
  dependsOn:
  - name: db
    type: Service
  networks:
  - name: app
    type: Ingress

apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  selector:
    app: db
  ports:
  - name: db
    port: 5432
  type: ClusterIP

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: grafana-db-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```
**Explanation:**

* We define a Deployment named `grafana` with a single replica.
* The Deployment template includes a single container with the same configuration as the Docker Compose file.
* We use a Persistent Volume Claim named `grafana-db-data` to request storage for the database.
* We define a Service named `db` to expose the database.
* We define an Ingress resource to allow incoming traffic to the `grafana` service.

Best practices:

* We use a Deployment to manage the lifecycle of the Grafana container.
* We use a Persistent Volume Claim to request storage for the database.
* We use a Service to expose the database to the `grafana` service.
* We use an Ingress resource to allow incoming traffic to the `grafana` service.
